<!DOCTYPE html>
<html lang="es">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <link rel="stylesheet" href="styles/style.css">
   <link href="https://fonts.googleapis.com/css?family=Bai+Jamjuree&display=swap" rel="stylesheet">
   <link href="https://fonts.googleapis.com/css?family=Barlow+Semi+Condensed&display=swap" rel="stylesheet">
   <link href="https://fonts.googleapis.com/css?family=Sanchez&display=swap" rel="stylesheet">
   <script src="js/scripts.js"></script>
   <title>Tema 3: Tipos de Dato</title>
</head>
<body>
   <div id="cabecera">
      <h1>Tipos de Dato</h1>
   </div>
   <!-- INICIO_LOADER -->
   <div id="pageloader">
      <img src="img/LogoOjo_FTA.png" class="spining" width="100px">
   </div>
   <!-- FIN_LOADER -->
   <div id="contenido">
      <h2>Byte</h2>
      <p class="texto">
         Byte almacena un valor numérico de 8 bits sin decimales. Tienen un rango entre 0 y 255
      </p>
      <p class="codigo">
         byte unaVariable = 180; // Declara 'unaVariable' como tipo byte
      </p>
      <h2>Int</h2>
      <p class="texto">
         Enteros son un tipo de datos primarios que almacenan valores numéricos de 16 bits sin decimales comprendidos 
         en el rango de -32.768 a 32.767.
      </p>
      <p class="codigo">
         int unaVariable = 1500; // Declara 'unaVariable' como una variable de tipo entero
      </p>
      <p class="nota">
         Nota: Las variables de tipo entero “int” pueden sobrepasar su valor máximo o mínimo como consecuencia de una 
         operación. Por ejemplo, si x = 32767 y una posterior declaración agrega 1 a x, x = x + 1 entonces el valor 
         se x pasará a ser -32768. (algo así como que el valor da la vuelta)
      </p>
      <h2>Long</h2>
      <p class="texto">
         El formato de variable numérica de tipo extendido “long” se refiere a números enteros (tipo 32 bits) sin 
         decimales que se encuentran dentro del rango -2.147.483.648 a 2.147.483.647.
      </p>
      <p class="codigo">
         long unaVariable = 90000; // Declara 'unaVariable' como tipo long
      </p>
      <h2>Float</h2>
      <p class="texto">
         El formato de dato del tipo “punto flotante” “float” se aplica a los números con decimales. Los números de 
         punto flotante tienen una mayor resolución que los de 32 bits con un rango comprendido entre -3.4028235E+38 
         y 3.4028235E+38.
      </p>
      <p class="codigo">
         float unaVariable = 3.14; // Declara 'unaVariable' como tipo flotante
      </p>
      <p class="nota">
         Nota: Los números de punto flotante no son exactos, y pueden producir resultados extraños en las 
         comparaciones. Los cálculos matemáticos de punto flotante son también mucho más lentos que los del tipo de 
         números enteros, por lo que debe evitarse su uso si es posible.
      </p>
      <h2>Array</h2>
      <p class="texto">
         Un array es un conjunto de valores a los que se accede con un número índice. Cualquier valor puede ser 
         recogido haciendo uso del nombre de la matriz y el número del índice.
         <br><br>
         El primer valor de la matriz es el que está indicado con el índice 0, es decir el primer valor del conjunto 
         es el de la posición 0. Un array tiene que ser declarado y opcionalmente asignados valores a cada posición 
         antes de ser utilizado
      </p>
      <p class="codigo">
         int miArray[] = {valor0, valor1, valor2...}
      </p>
      <p class="texto">
         <br>
         Del mismo modo es posible declarar una matriz indicando el tipo de datos y el tamaño y posteriormente, 
         asignar valores a una posición especifica:
      </p>
      <p class="codigo">
         int miArray[5]; // Declara un array de enteros de 6 posiciones<br>
         miArray[3] = 10; // Asigna el valor 10 a la posición 4
      </p>
      <p class="texto">
         <br>
         Para leer de un array basta con escribir el nombre y la posición a leer:
      </p>
      <p class="codigop">
         x = miArray[3]; // x ahora es igual a 10 que está en la posición 3 del array
      </p>
      <p class="texto">
         <br>
         Las matrices se utilizan a menudo para estamentos de tipo bucle, en los que la variable de incremento del 
         contador del bucle se utiliza como índice o puntero del array. El siguiente ejemplo usa una matriz para el 
         parpadeo de un LED.
         <br><br>
         Utilizando un bucle tipo for, el contador comienza en cero 0 y escribe el valor que figura en la posición de 
         índice 0 en la serie que hemos escrito dentro del array parpadeo[], en este caso 180, que se envía a la 
         salida analógica tipo PWM configurada en el PIN10, se hace una pausa de 200 ms y a continuación se pasa al 
         siguiente valor que asigna el índice “i”.
      </p>
      <p class="codigop">
         int ledPin = 10; // Salida LED en el PIN 10<br>
         byte parpadeo[] = {180, 30, 255, 200, 10, 90, 150, 60}; // Array de 8 valores diferentes<br><br>
         void setup()<br>
         {<br>
         &emsp;pinMode(ledPin, OUTPUT); // Configura la salida PIN 10<br>
         }<br><br>
         void loop() // Bucle del programa<br>
         {<br>
         &emsp;for(int i=0; i<8; i++) // Crea un bucle tipo for utilizando la variable i de 0 a 7<br>
         &emsp;{<br>
         &emsp;&emsp;analogWrite(ledPin, parpadeo[i]); // Escribe en la salida PIN 10 el valor al que<br>
         &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
         &emsp;&emsp;// apunta i dentro del array parpadeo[]<br>
         &emsp;&emsp;delay(200); // Espera 200ms<br>
         &emsp;}<br>
         } 
      </p>
      <br><br>
<!--
      <a class="texto volver" href="indexpro.html">Volver al índice</a>
-->
   </div>
   <div id="pie">
      <h1> Fun Tech Academy - Calle Alcobendas, 23 Leganés 28914 Madrid - www.funtech.academy </h1>
	</div>
</body>
</html>